<!DOCTYPE html>
<html class="csstransforms csstransforms3d csstransitions">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title></title>
    <meta charset="utf-8" />
    <link href="Content/font-awesome.min.css" rel="stylesheet" />
    <link href="Content/bootstrap.min.css" rel="stylesheet" />
    <link href="Content/style.css" rel="stylesheet" />

</head>
<body>

    <nav class="navbar navbar-default" role="navigation">
        <div class="container">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="#" style="font-size: 23px;"><img src="Content/images/logo/logo-small.png" style="float:left;" />&nbsp;Junxing's Interstellar</a>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse navbar-right" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav">
                    <li class="active"><a href="#">Home</a></li>
                    <li><a href="#">Skill</a></li>
                    <li><a href="#">Project</a></li>
                    <li><a href="#">Contract</a></li>
                </ul>
            </div><!-- /.navbar-collapse -->
        </div><!-- /.container-fluid -->
    </nav>

    <div class="container mtb">
        <div class="row">
            <!-- -- SINGLE POST ---->
            <div class="col-lg-8 col-md-8 col-sm-8">
                <!-- -- Blog Post  ---->
                <a href="/blog/2015/sfd2015/"><h3 class="ctitle">并发程序中“死锁”的来龙去脉</h3></a>
                <p><csmall>Apr 8, 2016. | By: Junxing</csmall></p>
                <div class="post-content">
                    <p>
                        一个并发的应用程序有两个重要的性质，安全性与活跃性，由于安全性的需要，并发程序引入了锁机制，俗称“加锁”。
                        “加锁”充分提高了程序的安全性，它是以牺牲掉程序效率的方式来实现的，即降低了其活跃性。
                        锁的不合理使用还会导致线程阻塞，相互永久等待，也就是我们称的“死锁”，它是一种活跃性风险。
                        我们需要正确地使用锁机制，避免“死锁”，又保证线程安全，实现安全性与活跃性之间的平衡，这是编写并发程序的关键。
                    </p>

                    <p>
                        <img src="Content/images/article/加锁.PNG" />
                    </p>

                    <!-- more -->

                    <p>
                        以上谈到了为什么要加锁，而且是要正确地加锁。接下来我们谈一下Java的内部锁机制，同步代码块（Synchronized Block）和Volatile变量。
                        <ul>
                            <li>
                                在Java语法上，通过使用synchronized关键字来实现同步代码块，关键字synchronized可以用来修饰方法，得到横跨整个方法体的同步代码块。
                                <br />
                                <img src="Content/images/article/synchronized.PNG" />
                                <br />
                                其中同步代码块的锁就是方法调用的对象，也可以作为静态的synchronized方法来实现，同时以Class对象作为锁。
                                <br />
                                在Java中，在同一个时刻，只能有一个线程能够持有这种锁。当线程A尝试获取线程B持有的一个锁时，线程A必须等待或者阻塞，直到线程B释放这个锁，如果线程B永远不释放这个锁，那么线程A将永远地等待下去。
                            </li>
                            <li>
                                volatile变量是一种比synchronized关键字更轻量级的同步机制。
                                编译器会注意到volatile变量是共享的，不会将该变量上的操作和其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者其他处理器不可见的地方，因此在读取volatile类型的变量时，总是会返回时刻最近的那个线程写入的最新值。
                                <br />
                                <img src="Content/images/article/volatile.PNG" />
                                <br />
                                对比同步代码块，从内存可见性的角度来看，写入volatile变量相当于退出同步代码块，读取volatile变量相当于进入同步代码块。
                            </li>
                        </ul>
                    </p>

                    <p>
                        应用了锁机制后，我们的程序安全性得到了保证，然而程序就完美了么？显然我们可能会碰到更严峻的活跃性风险，死锁。
                        我们这样来理解死锁的定义，当两个一样优秀的男生都在追求同一个女孩时，女孩无法选择，于是两个男生都将永远地等待下去。在计算机世界，永远地等待，以为着程序成为了“植物人”，失去了任何意义。
                    </p>

                    <p>
                        <img src="Content/images/article/deadlock.jpg" />
                    </p>

                    <p>
                        接下来，我们具体谈一下“死锁”，在实际情况中，死锁又分为以下几种情形：锁顺序死锁、动态锁顺序死锁、在协作对象时发生的死锁。
                        <ul>
                            <li>
                                锁顺序死锁，线程A得到了Left锁，尝试获得Right锁，于是等待。与此同时，线程B得到了Right锁，尝试获得Left锁，于是等待。它们都想要得到对方的锁，才能继续运行，所以它们永久地等待下去。
                                锁顺序死锁发生的原因就是因为两个方法中获得锁的顺序不一致所导致的。
                                <br />
                                <img src="Content/images/article/Lock-Ordering Lock.png" />
                            </li>
                            <li>
                                动态锁顺序死锁，我们可能汲取了锁顺序死锁的教训，在代码中只写一种方法，但是我们被锁的对象却是动态的，一前一后，实际上还是有两种锁顺序不一致的线程。
                                <br />
                                <img src="Content/images/article/deadlock-prone.png" />
                            </li>
                            <li>
                                在协作对象时发生死锁，虽然我们没有在一个方法内放置两个锁，但是在程序协作对象时，依旧可能出现，线程A得到对象a的锁，尝试获得对象b的锁，于是等待，线程B得到了对象b的锁，尝试获得对象a的锁，于是等待。锁顺序依旧不同，继而导致死锁。
                            </li>
                        </ul>
                    </p>

                    <p>
                        以上“死锁”的危害足够引起我们的重视，那么我们应该如果避免死锁呢？或者程序bug了，我们如何诊断死锁呢？
                        从预防说起，一个完美的但不现实的方法是，在一个程序中，我们应该只使用一个锁。这样自然不会出现锁顺序不同的问题，避免了Deadlock。
                        当我们需要用到多个锁时，在设计时应该尽量避免多个锁的交互使用，将获得锁时所要遵循的协议写入正式的文档，并始终遵循这种协议。
                        设计完成后，我们应该采取这样一个策略来检查，首先，找到使用多个锁的位置，然后对所有的实例进去分析，确保所有预想到的实例的锁顺序都是一致的。
                        同时，我们在设计被调用的方法时，不要让调用者必须先获得锁，才能调用。这种设计也叫做是开放调用。
                    </p>

                    <p>
                        <img src="Content/images/article/thread dump.PNG" />
                    </p>

                    <p>
                        当程序真正发生死锁时，该怎么办？JVM提供了线程转储（Thread Dump）来帮助识别死锁的发生。
                        线程转储包括了各个运行中的线程的栈追踪信息，还包含了加锁信息。
                        它能够通过搜索循环来找出死锁，如果发现了一个死锁，则会获取相应的死锁信息，以及这个锁的获取操作是在程序的哪个位置。许多IDE都集成了线程转储功能，诊断死锁问题，这无疑是一把超级好用的手术刀。
                    </p>

                </div>
                <div class="spacing"></div>
                <!-- <h6>SHARE:</h6>
                <p class="share">
                    <a href="#"><i class="fa fa-twitter"></i></a>
                    <a href="#"><i class="fa fa-facebook"></i></a>
                    <a href="#"><i class="fa fa-tumblr"></i></a>
                    <a href="#"><i class="fa fa-google-plus"></i></a>
                </p> -->
            </div><!-- --/col-lg-8 ---->

        </div><!-- --/row ---->
    </div>

    <!--
    vim: ts=2 sts=2 sw=2 expandtab
    -->

    <div id="footerwrap">
        <div class="container">
            <div class="row">

                <div class="col-sm-4">
                    <p>这个站点的样式，完全采用的清华tuna协会改进Bootstrap后的样式，除此之外，这个小站点里，服务器是我自己的，域名是我自己的，文章是我自己的。不对，文章是马伊琍的。</p>
                </div>

                <div class="col-sm-4">
                    <h4>Contact Us</h4>
                    <div>
                        <ul class="social">
                            <li>
                                <a href="https://groups.google.com/forum/#!forum/tuna-general"><i class="fa fa-envelope"></i> Mailing List</a>
                            </li>
                            <li>
                                IRC: <a href="/irc/">#tuna at freenode</a>
                            </li>
                            <li>
                                <a href="https://github.com/tuna/"><i class="fa fa-github"></i> GitHub </a>
                            </li>
                            <li>
                                <a href="https://secure.flickr.com/groups/tuna/"><i class="fa fa-flickr"></i> Flickr</a>
                            </li>
                            <li>
                                <a href="http://weibo.com/u/5402274706"><i class="fa fa-weibo"></i> 新浪微博</a>
                            </li>
                            <li>
                                <a href="http://page.renren.com/601908241"><i class="fa fa-renren"></i> 人人公共主页</a>
                            </li>
                        </ul>
                    </div>
                </div>

                <div class="col-sm-4">
                    <img class="img-responsive" src="Content/images/logo/logo-white.png" />
                </div>
            </div><!-- --/row ---->
        </div><!-- --/container ---->
    </div>


    <script src="scripts/jquery-2.1.1.min.js"></script>
    <script src="scripts/bootstrap.min.js"></script>
</body>
</html>
